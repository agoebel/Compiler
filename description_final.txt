The entry point for the program is the function main(). 

Lines 58 - 98 read command arguments and detect whether input is to be processed from file or from stdin. 

The init() function in main.c, line 98, initializes two global constant variables: 
	- MARKER of type VElement* used to mark the begining of a variable scope
	- SS of type VStack used to hold all the variables when running the semantic analyzer

The data types for these two constructs are defined in semantic.h. 

Thus, SS contains an array of VElement* accesible through the field called "vars", which will hold all the variables in the program. Moreover, for each variable we will also store the line where this variable occurs. There is also a field caled topIndex which is the index of the element located at the top of the stack. 

MARKER is of type VElement* and uses a char* field called "data" which will hold the actual name of the variable. For the MARKER element this field will be empty.

Lines 103 - 105 in main.c read the lookup table, and open the input file handle. 

The call to parse() on line 107 in main.c, starts the actual parsing process and returns the root node for the Abstract Parser Tree.

This function is implemented in the file parse.c and the process is described next.

Key to the parsing process is translating each non-terminal and terminal from the grammar into a function. 

Thus, a rule of the form PROGRAM -> <VAR> <BLOCK> can be equated to a call to a function called PROGRAM in which we should expect to find a token <PROGRAMtk> and, if we scan some more, we should also find the tokens <VARtk> and <BLOCKtk>.

The function PROGRAM() in line 17 in parser.c verifies first that the currently read symbol is <PROGRAMtk> (line 19), reads the next token from the input file (line 21) and calls the VAR() and BLOCK() functions. Similarly the VAR() function will make sure that the currently read symbol (which was read in PROGRAM() line 21) will correspond to a <TYPEtk> token followed by one or more <IDtk> tokens. This simple model, consisting of translating gramar symbols into function calls, and checking inside each function that the correct token was read by the scanner, effectively leads to a complete and correct parsing of the input file. 

In addition to this, as parsing happens, the Abstract Parse Tree (APT) is constructed. Thus, the PROGRAM() function will return a node (line 32 in parser.c) which will have two children: 
	- a varNode returned by the call to VAR() in line 24
	- a blockNode returned by the call to BLOCK() in line 26

These are added as children to the root node of the tree by the calls to addChildNode in lines 33 and 34 in parser.c. Looking at the code for the addChildNode function (line 210) a check is performed to avoid adding NULL nodes to the tree. NULL nodes will be returned by calls to token-functions (e.g. VAR()) which transition to the empty symbol in the grammar rules. We do not include them and thus reduce the size of the APT without affecting the functionality of the program.

This process is repeated for every single token which is found in the input file, resulting in an APT which is returned in main.c in line 107.

Once the APT is constructed, semantic analysis can begin. This is initiated by a call to the function performSemanticAnalysis passing as a parameter the root node of the APT (line 110 in main.c). This function is implemented in semantic.c line 415 and consists of two operations:
	- pushing the scope MARKER on the scope stack SS, indicating that a new variable scope begins (in this case, the global scope)
	- a call to traversing the APT in preorder (line 420, semantic.c)

Every APT node is of type APTNode*, and the underlying structure has the following fields (defined in semantic.h, line 36):
	- numChildren of type int indicating the number of children nodes for the current node
	- children which is an array of pointers to APTNode, storing pointers to children nodes
	- attr which is of type APTAttributes, holding information about the node

Each node has some attributes depending on the token it represents. The APTAttributes structure is defined in semantic.h line 29 and has the following fields (all of type char*):
	- token field (e.g. "<PROGRAMtk>", "<IDtk>", etc.)
	- name field (NULL except when token is "<IDtk>" when it holds the variable name associated to this node)
	- value field (NULL except when token is "<Numbertk>" when it holds the value of the number; e.g. "12", "13", etc.)
	- line field (the line in the input file where the token appears)

The attr field of the APTNode structure holds node attributes. This is what annotation means - assigning attributes to the parse tree nodes.

With these concepts we are ready to analyze how semantic analysis happens in preOrderSemanticAnalysis (semantic.c, line 373). Remember that this was called from performSemanticAnaysis() (line 420, semantic.c). 

Schematically this is the flow:
main():line 110 main.c: -> performSemanticAnalysis():line 415 semantic.c: -> preOrderSemanticAnalysis():line 373 semantic.c

The key programming technique used in performing semantic analysis is recursion. The algorithm is:

For each child node of the current tree node:
	A. If the child node is a VAR node, check child node for variable redeclarations and when done consider this child node completely explored
	B. Else if the child node which stands for a statement where a variable might be used (SCANF, PRINTF, a =, a + 1), check child node for variable declaration before use
	C. Else the child node is not immediately related to variable use or declaration, but its children might be, so recursively examine the subtree of the child node (the tree which has the child node as root node)

Step A. is implemented in semantic.c line 332 by the function checkVariableDeclarationsPreOrder.
Step B. is implemented in semantic.c line 352 by the function checkVariableUsePreOrder.
Step C. is basically a recursive call to the preOrderSemanticAnalysis() function with the child node as a parameter

Apart from these 3 steps, the Scope Stack SS, needs to be maintained as the tree is explored. Thus, before examining each child node of the current tree node (the A, B, C algorithm above), we determine whether we are begining a new scope with the current node, line 379 semantic.c. This happens whenever the current node is a node corresponding to a <BLOCKtk> token. Whenever this occurs we have to push a MARKER VElement in the SS stack because a new variable scope begins and we need to differentiate between upcoming local variables and the variables existing in previous scopes. When we analyze the SS stack we will know that a new scope starts whenever a MARKER element is found. 

Also, we need to remove all local variables from the scope stack SS, including the MARKER element, whenever a <BLOCKtk> node has been completely processed. This is taken care of in by performing a call to popCurrentScopeVars() in line 411, semantic.c. Note that this happens after all children nodes for the current node have been completely processed (including those which required recursive calls). 

Schematically a BLOCK node is processed like this:

preOrderSemanticAnalysis(<BLOCKtk>)
	* push MARKER
	* check first var child node for variable redeclarations (if such a node exists)
	* check second var child node for variable redeclarations (if such a node exists)
	* ...
	* check first statement for variable use before declaration (if the statement is a statement where a variable can appear)
	* check second statement for variable use before declaration (if the statement is a statement where a variable can appear)
	* ...
	* pop local variables & MARKER

The function used for checking variables for redeclaration is checkVariableDelcarationsPreOrder(). A <VAR> node has the following tree structure:
<VARtk>
|
+--<TYPEtk>
|
+--<IDtk> (1)
|
+--<MVARS>
      |
      +--<IDtk> (2) 
      |
      +--<MVARS>
            |
            +--<IDtk> (3)
            |
            +--<MVARS>
                  |
                 ...

To process the entire <VARtk> node, we need to analyze for redeclaration all <IDtk> tokens that appear as children in the entire subtree. This calls for recursivity. Thus, we first analyze whether the node we are currently exploring is an <IDtk> node, check whether it is redeclared or not, and if it is not, push it on the scope stack. Then we proceed by analyzing the remaining nodes in the current subtree by making a recursive call to checkVriableDeclarationsPreOrder(). This effectively explores the <VARtk> subtree.

The function used for checking variables for use before declaration is checkVaiableUsePreOrder(). This too uses recursivity in the same manner as the previously described function. First the currently explored node is examined. If it is of type <IDtk> then a check is performed to determine whether it has been declared or not. After this all other node children are explored as well. 

The two functions which check for variable redeclaration and use-before-declaration are checkRedeclared and checkNotDeclared respectively. 

checkNotRedeclared() is implemented in semantic.c line 320 and makes a call to findInAllScopes() which analyses the underlying array of SS from index 0 to index SS->topIndex to check whether there exists a VElement with a name field matching that of the current variable.

checkRedeclared() is implemented in semantic.c line 307 and makes a call to findInLocalScope(). This function analyses the underlying array of SS from index SS->topIndex towards 0, until it finds the first MARKER element. This space will be occupied by local variables and a check whether there exists a VElement with a name field matching that of the current variable is performed.

Whenever an error occurs (i.e. the variable is not defined or variable is redeclared) the program makes a call to the exit() system function along with an error message including the line where the token appears. 

Take line 313 from semantic.c for example:
printf("%s:%d: semantic error: redeclaration of '%s'; previous declaration on line %d ", filename, var->attr.line, var->attr.name, prevLineNo);

The line number is retrieved using the attr.line node attribute. The name of the variable which breaks semantic rules is retrieved using the attr.name node attribute.

This completes semantic analysis. 

Code generation is invoked only if semantic analysis does not yield an error. The entry point for the code generator is the call to generate() in main.c line 122. 

The generate() function is implemented in generator.c line 632. The function receives as parameters the root node of the APT tree (which is exactly what the parser returns), the output file "out" where the code is generated. 

The code generator uses 4 data structures: 
	- the variable Scope Stack (SS)
	- an Operator Stack (opStack)
	- a Result Stack (resStack)
	- a stack holding all the names of the variables appearing in the program

All are defined as global and accessible in any point of the code. 

Another global constant used by the generator code is that for a variable called ZERO. This variable is of type VElement and will be used to implement the <F> -> <MINUS> <F> grammar rule. More details on this will follow.

Lines 636 - 653 from generator.c initialize the 4 stacks and the ZERO element. 

The code reaches a junction point where two possibilities exists:

1. The APT corresponds to an input .cp file WITHOUT variable declarations:
   PROGRAM
   BEGIN
       ...
   END.

OR

2. The APT corresponds to an input .cp file WITH variable declarations:
   PROGRAM
   INT A...;
   BEGIN
       ...
   END.

Case 1 is handled in generator.c line 672. In this situation, since there are no variables defined globally, we do not need to add the MARKER to the scope stack. All we have to do is explore the first and only child of the <PROGRAMtk> node (recGen() in line 676). Here is how the APT looks like in this case:

<PROGRAMtk>
|
+-<BLOCK> -> child of index 0

Case 2 is handled in generator.c line 656. In this situation, there are variables defined. This means that we have to add the MARKER to SS (push() in line 659) , add the local variables (pushExistingVars() in line 663), traverse the <BLOCKtk> node (recGen() in line 666), pop local variables (popExistingVars() in line 669) and pop the MARKER element (pop() in line 671). Here is how the APT looks like in this case:

<PROGRAMtk>
|
+--<VARtk> -> child of index 0
   |
   +--<TYPEtk>
   |
   +--<IDtk>
   |
   +--<MVARS>
      |
      +--<IDtk>
      |
      ...
+--<BLOCK> -> child of index 1
   |
   ...

pushExistingVars() starts up with a <VARtk> node as parameter and does the following:
	- adds the current variable to the distinct variable names stack if this variable name was not encountered before (line 361, generator.c)
	- if the current variable was already defined in a previous scope, it generates the ASM instructions needed to save the old value of the variable (lines 372-374, generator.c)
	- the remaining variables are analyzed using a recursive call to pushExistingVars

The instructions needed to save the old value of the variable consists of a PUSH (creates a slot on the stack space), LOAD variable, which loads the value of the variable into ACC and a STACKW instruction which writes the value of ACC on the newly allocated stack space. Note that this is the actual program stack used by the assembler interpreter and not one of the programmer defined stacks introduced above.

E.g. Consider the following input file:

PROGRAM
INT a, b;
BEGIN
 ...
END.

The APT is:

<PROGRAMtk>                    ;Pointer Address: 0x01
|
+--<VARtk>                     ;Pointer Address: 0x02
   |
   +--<TYPEtk>                 ;Pointer Address: 0x03
   |
   +--<IDtk> (name = a)        ;Pointer Address: 0x04
   |
   +--<MVARS>                  ;Pointer Address: 0x05
      |
      +--<IDtk> (name = b)     ;Pointer Address: 0x06
+--<BLOCK> -> child of index 1 ;Pointer Address: 0x07
   |
   ...

The function call flow is this:

pushExistingVars(0x02)
  findInAllScopes("a") ---> push("a")
  findInPreviousScopes("a") ---> NOTHING
  push("a", SS)
  pushExistingVars(0x05)
    findInAllScopes("b") ---> push("b")
    findInPreviousScopes("b") ---> NOTHING
    push("b", SS)
    return from recursive call
  return from recursive call
end.

Please note that children ar traversed from left to right, which means that variables are processed in the order in which they appear in the declaration.

popExistingVars() works similarly to pushExistingVars, with the only difference that it undos operations. Thus, if a given variable that was defined locally exists in previous scopes, it means that there is some ASM code generated to preserve its value. We need to restore its value by performing a STACKR (ACC = STACK[top]), a STORE varName (varName = ACC), POP (top = top - 1). These are performed in lines 327-330 in generator.c.

An interesting thing to note here is that recursivity happens before the current node is processed. This leads to a right to left traversal of the <VARtk> tree node. 

The function call for the example given above would be:

popExistingVars(0x02)
  popExistingVars(0x05)  
     findInPreviousScopes("b") ---> NOTHING
     pop("b", SS)
     return from recursive call
  findInPreviousScopes("a") ---> NOTHING
  pop("a", SS)
  return from recursive call
end.

The reason why right-to-left is the correct approach for popping variables is because they will be available on the stack in the reverse order of apparition. In this case the stack after pushExistingVars is:

"b" <-- top of the stack
"a"

When we pop, we need to restore "b" first. 

These observations related to <VARtk> nodes are valid not only when analyzing a <PROGRAMtk> node, but also when a <BLOCKtk> node is encountered. There is actually no difference.

Moving on, to the core of the generator, the recGen() function (line 444 generator.c).

The main idea behind recGen() is to traverse the APT and generate code for each node which must generate code.

Here is a list of all nodes which generate code and their translation
A. <Numbertk> : 0 children : : -> LOAD 3  (loads node->attr.value in ACC)
B. <IDtk> : 0 children : : -> LOAD x (loads node->attr.name in ACC)
C. <INtk> : 2 children : <SCANFtk> <IDtk> :  -> READ x
D. <OUTk> : 2 children : <PRINTFtk> (<IDtk> | <EXPRtk>) : 
    D.1. Evaluate child of index 1 (btw, child of index 0 is <PRINTtk>) and store in ACC (line 478)
    D.2. MOVE value in ACC in new variable argR (line 480)
    D.3. WRITE argR (line 484)
E. <ASSIGNtk> : 3 children : <IDtk> <EQtk> <EXPRtk> : 
    E.1. Evaluates child of index 2 and stores in ACC (line 491)
    E.2. STORE node->children[0]->attr.name (writes the value in ACC into the variable denoted by <IDtk>)
F. <IFtk> : 4 children : <EXPRtk1> <RO> <EXPRtk2> <BLOCK>
    F.1. Evaluates expression <EXPRtk2> in ACC
    F.2. Creates new variable name (line 505)
    F.3. Stores ACC into new variable (line 508)
    F.4. Evaluates expression <EXPRtk1> in ACC
    F.5. Subs from ACC variable created in F.3.
    F.6. Compares the result to 0 depending on the value of <RO> (line 520)
    *e.g.* if RO is <, then we have if (e1 < e2); acc = e1 - e2; thus for < if acc < 0 then the condition is true; the condition is not true if acc is 0 or positive; when translating the if we will use the BRPOS and BRZERO asm statements to jump to the LOOP which takes us outside the if block;
G. <LOOPtk> : 4 children :  <EXPRtk1> <RO> <EXPRtk2> <BLOCK>
    It is identical to the if statement. The only distinction is that before following steps F.1-6 we need to add a loop_123: noop statement and the pairing BR loop_123 statement to repeat the loop. The logic of transforming the loop is this: 
 LOOP_IN: NOOP
           ASM INSTRUCTIONS FOR EVALUATING THE CONDITION
           BR TO LOOP_OUT STATEMENTS IF THE CONDITION IS UNTRUE
           INSIDE LOOP STATEMENTS COME HERE
           BR TO LOOP_IN TO REPEAT THE LOOP
 LOOP_OUT: NOOP
           OUTSIDE LOOP HERE

H. <BLOCKtk> : 1 or 2 children :
    H1. if one child then traverse the child (no vars)
    H2. if two children, treat the <VARtk> node as described above, and traverse the other child node
I. <EXPRtk> : 
    I.1. evaluateExpression()
    I.2. reduceParanthesis()
J. other
    Simply traverse. This takes care of all other nodes and explores their children 

The evaluateExpression() function is used to evaluate the value of expressions. It is implemented in generator.c line 215. It is a recursive function which explores, for each node its children and also performs a number of actions depending on the node type. Looking at the grammar for expressions we distinguish 5 different cases:
1. The current node is <IDtk> or <Numbertk> node (line 225)
2. The current node is <T> or <R> (line 238)
3. The current node stands for <MINUStk> <F> (line 244)
4. The current node stands for <(> <EXPR> <)> (line 257)
5. The current node stands for <F> * <T> OR <F> / <T> OR <T> + <E> OR <T> - <E> (line 268)

The algorithm used for evaluating expressions is the Shunting-yard algorithm (http://en.wikipedia.org/wiki/Shunting-yard_algorithm). It is adapted for the task at hand. 

According to this algorithm, as the children of the <EXPRtk> node are explored the following actions are taken:
A. if a number of identifier is encountered it is pushed on the RESULTS STACK
B. if an operator is encountered (see case 5 above) then:
	* while there is an operator at the top of the OPERATOR STACK with a higher precedence than the encountered operator
		[.] pop the topmost two operands from the RESULT STACK and apply the operator at the top of OPERATOR STACK
		[.] pop operator on top of the OPERATOR STACK and push the result on the RESULT_STACK
        * push the encountered operator on the OPERATOR STACK
C. if a left paranthesis is encountered, push it on the OPERATOR STACK
D. if a right paranthesis is encountered, evaluate all operators on the OPERATOR STACK until the pairing left paranthesis; pop left paranthesis
E. at the end of the procedure, evaluate the operators which have remained on the OPERATOR STACK

Step A corresponds to case 1 above and is implemented in lines 232 and 236 respectively.
Step B corresponds to case 5 above and is implemented by the call to function putOperatorOnStack on line 274
Step C corresponds to case 4 above and is implemented in line 262
Step D corresponds to the end of case 4 and is implemented by the call to function reduceParanthesis in line 267

The function putOperatorOnStack() (line 158) receives an operator crtOp as parameter and does the following:
	1. Examines the operator on the top of the stack topOp
	2. If topOP is left paranthesis, then we can simply push crtOp on the operator stack
	3. While the precedence of crtOp is lower than the precedence of topOp, perform the operation denoted by topOp and the top two numbers from the RESULT_STACK (call to performOperationWithACC() in line 191); the result is stored in ACC
	4. Otherwise it's okay to push crtOp on the OPERATOR STACK so we break (line 195) and push crtOp (line 211)
	5. Moreover if operations were performed in step 3, we need to move the result from ACC and store it into a variable (line 205)

The function reduceParanthesis() (line 103) is similar to putOperatorOnStack() with the only difference that it pops the left paranthesis (line 153) and does not place an operator on the operator stack. Thus, while left paranthesis is not on the top of the OPERATOR STACK, we take one operator from this stack and the corresponding two operands on the top of RESULT STACK and apply the operator to the operands and store in ACC (call to performOperationWithACC() in line 137).

The function performOperationWithACC() is implemented in line 65 in generator.c and takes an operand from the top of the stack. The second operand is ACC. This means that beforemaking a call to performOperationWithACC the other operand must be already loaded in ACC. Do note, that this is implemented for both reduceParanthesis() (line 127) and putOperatorOnStack() (line 158). The operand is then examined:
	* if the operand is + or * then we simply generate "ADD varName" where varName is the top element from the operand stack
	* if the operand is -, then we need to compute ACC = varName - ACC; it's easier to compute ACC = ACC * (-1) followed by ACC = ACC + varName than to store ACC in var2, load varName in acc and then generate SUB var2. It takes one additional variable and one additional statement
	* for / we have no choice but to switch; i.e. var2 = ACC; ACC = varName; DIV var2;

As a last note the <MINUStk> <F> case is implemented by artificially pushing the ZERO global constant on the RESULTS STACK (line 249) and the <MINUStk> on the OPERATOR STACK and further evaluating <F>. This will evaluate <F> and then evaluate ZERO - <F>, yielding -F. 

I hope this clears up stuff. I can't honestly go into more detail than this but the code itself is commented and variables are named in such a way that their behaviour is apparent from their name. Also, there is a DEBUG file in generator.c line 7;

#define DEBUG 0

If you change this to 

#define DEBUG 1

you will have verbose output of what the program does. I have used this to track errors in the program. It takes some patience to get used to it, but it can really help. 

Do not hesitate to contact me for any other questions :) I'm glad to help.

